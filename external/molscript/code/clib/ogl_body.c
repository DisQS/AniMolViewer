/*
  OpenGL rendering of the geometry for various bodies.
  The rendering is done directly (no display lists) and is suitable
  for compilation into display lists. The faces are rendered correctly
  for face culling using the default counter-clockwise mode.

  clib v1.1

  Copyright (C) 1998 Per Kraulis
   10-Jun-1998  first attempts

to do:
- sphere solid, ico subdivide 
- cone
- ellipsoid
*/

#include "ogl_body.h"

/* public ====================
#include <vector3.h>
==================== public */

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include <GL/gl.h>

#include <angle.h>
#include <body3d.h>
#include <ogl_bitmap_character.h>


/*============================================================*/
static vector3 *sphere_icopoints = NULL;
static int sphere_icopoint_count, sphere_icopoint_level = 0;
static vector3 *tetrahedron = NULL;
static vector3 *octahedron = NULL;
static vector3 *cube = NULL;
static vector3 *icosahedron = NULL;

static const vector3 xaxis = {1.0, 0.0, 0.0};
static const vector3 yaxis = {0.0, 1.0, 0.0};

#define NO(p) glNormal3d ((p)->x, (p)->y, (p)->z)
#define VX(p) glVertex3d ((p)->x, (p)->y, (p)->z)
#define NOD(p) glNormal3d (p.x, p.y, p.z)
#define VXD(p) glVertex3d (p.x, p.y, p.z)
#define VXR(p) glVertex3d(radius*(p)->x+x, radius*(p)->y+y, radius*(p)->z+z)
#define VXRD(p) glVertex3d (radius*p.x+x, radius*p.y+y, radius*p.z+z)


/*------------------------------------------------------------*/
static void
average_3_normals (vector3 *p1, vector3 *p2, vector3 *p3)
{
  vector3 normal;

  assert (p1);
  assert (p2);
  assert (p3);

  normal.x = p1->x + p2->x + p3->x;
  normal.y = p1->y + p2->y + p3->y;
  normal.z = p1->z + p2->z + p3->z;
  v3_normalize (&normal);
  NOD (normal);
}


/*------------------------------------------------------------*/
void
ogl_sphere_vertices_ico (vector3 *pos, double radius, int level)
     /*
       Render points on a sphere generated by subdividing the
       icosahedron. The level controls the granularity.
     */
{
  vector3 *point;
  register int slot;
  register double x, y, z;

  /* pre */
  assert (pos);
  assert (radius > 0.0);
  assert (level >= 1);

  if (sphere_icopoint_level != level) {
    if (sphere_icopoints) free (sphere_icopoints);
    sphere_icopoints = sphere_ico_points (level);
    sphere_icopoint_count = sphere_ico_point_count (level);
    sphere_icopoint_level = level;
  }
  point = sphere_icopoints;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_POINTS);
  for (slot = 0; slot < sphere_icopoint_count; slot++) {
    VXR (point);
    point++;
  }
  glEnd();
}


/*------------------------------------------------------------*/
static void
sphere_faces_ico_divide (vector3 *p1, vector3 *p2, vector3 *p3,
			 vector3 *pos, double radius, int depth)
{
  assert (p1);
  assert (p2);
  assert (p3);
  assert (pos);
  assert (radius > 0.0);

  if (depth <= 0) {
    register double x, y, z;
    x = pos->x;
    y = pos->y;
    z = pos->z;

    NO (p1);
    VXR (p1);
    NO (p2);
    VXR (p2);
    NO (p3);
    VXR (p3);

  } else {
    vector3 p12, p23, p13;
    v3_sum (&p12, p1, p2);
    v3_normalize (&p12);
    v3_sum (&p23, p2, p3);
    v3_normalize (&p23);
    v3_sum (&p13, p1, p3);
    v3_normalize (&p13);
    sphere_faces_ico_divide (&p13, p1, &p12, pos, radius, depth-1);
    sphere_faces_ico_divide (p3, &p13, &p23, pos, radius, depth-1);
    sphere_faces_ico_divide (&p23, &p13, &p12, pos, radius, depth-1);
    sphere_faces_ico_divide (&p23, &p12, p2, pos, radius, depth-1);
  }
}


/*------------------------------------------------------------*/
void
ogl_sphere_faces_ico_recursive (vector3 *pos, double radius, int depth)
     /*
       Recursive division of icosahedron triangles into a sphere.
       Requires mode glShadeModel(GL_SMOOTH) for correct rendering.
     */
{
  /* pre */
  assert (pos);
  assert (radius > 0.0);
  assert (depth >= 0);

  if (icosahedron == NULL) icosahedron = icosahedron_vertices();

  glBegin (GL_TRIANGLES);
  sphere_faces_ico_divide (icosahedron + 0, icosahedron + 2, icosahedron + 1,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 0, icosahedron + 1, icosahedron + 4,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 0, icosahedron + 4, icosahedron + 8,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 0, icosahedron + 8, icosahedron + 3,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 0, icosahedron + 3, icosahedron + 2,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 9, icosahedron + 5, icosahedron + 7,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 9, icosahedron + 7, icosahedron + 10,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 9, icosahedron + 10, icosahedron + 11,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 9, icosahedron + 11, icosahedron + 6,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 9, icosahedron + 6, icosahedron + 5,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 1, icosahedron + 5, icosahedron + 6,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 1, icosahedron + 6, icosahedron + 4,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 6, icosahedron + 11, icosahedron + 4,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 11, icosahedron + 8, icosahedron + 4,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 11, icosahedron + 10, icosahedron + 8,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 10, icosahedron + 3, icosahedron + 8,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 10, icosahedron + 7, icosahedron + 3,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 7, icosahedron + 2, icosahedron + 3,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 7, icosahedron + 5, icosahedron + 2,
			   pos, radius, depth);
  sphere_faces_ico_divide (icosahedron + 5, icosahedron + 1, icosahedron + 2,
			   pos, radius, depth);
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_sphere_faces_globe (vector3 *pos, double radius, int segments)
     /*
       Render a sphere using the globe subdivision. The segments
       number controls the granularity.
       Requires mode glShadeModel(GL_SMOOTH) for correct rendering.
     */
{
  vector3 point;
  double x, y, z, angle, z1, z2, sr1, sr2, sinangle, cosangle;
  int slices, stacks, slice, stack;

  /* pre */
  assert (pos);
  assert (radius > 0.0);
  assert (segments >= 2);

  slices = 2 * segments;
  stacks = segments;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_TRIANGLE_FAN);
  point.x = 0.0;
  point.y = 0.0;
  point.z = 1.0;
  NOD (point);
  VXRD (point);
  angle = ANGLE_PI / (double) stacks;
  sr1 = sin (angle);
  z1 = cos (angle);
  point.x = sr1;
  point.y = 0.0;
  point.z = z1;
  NOD (point);
  VXRD (point);
  for (slice = 1; slice < slices; slice++) {
    angle = (double) slice * 2.0 * ANGLE_PI / (double) slices;
    point.x = sr1 * cos (angle);
    point.y = sr1 * sin (angle);
    NOD (point);
    VXRD (point);
  }
  point.x = sr1;
  point.y = 0.0;
  point.z = z1;
  NOD (point);
  VXRD (point);
  glEnd();

  for (stack = 1; stack < stacks - 1; stack++) {
    glBegin (GL_QUAD_STRIP);
    angle = (double) (stack + 1) * ANGLE_PI / (double) stacks;
    sr2 = sin (angle);
    z2 = cos (angle);
    point.x = sr2;
    point.y = 0.0;
    point.z = z2;
    NOD (point);
    VXRD (point);
    angle = (double) stack * ANGLE_PI / (double) stacks;
    sr1 = sin (angle);
    z1 = cos (angle);
    point.x = sr1;
    point.y = 0.0;
    point.z = z1;
    NOD (point);
    VXRD (point);
    for (slice = slices - 1; slice >= 1; slice--) {
      angle = (double) slice * 2.0 * ANGLE_PI / (double) slices;
      cosangle = cos (angle);
      sinangle = sin (angle);
      point.x = sr2 * cosangle;
      point.y = sr2 * sinangle;
      point.z = z2;
      NOD (point);
      VXRD (point);
      point.x = sr1 * cosangle;
      point.y = sr1 * sinangle;
      point.z = z1;
      NOD (point);
      VXRD (point);
    }
    point.x = sr2;
    point.y = 0.0;
    point.z = z2;
    NOD (point);
    VXRD (point);
    point.x = sr1;
    point.y = 0.0;
    point.z = z1;
    NOD (point);
    VXRD (point);
    glEnd();
  }

  glBegin (GL_TRIANGLE_FAN);
  point.x = 0.0;
  point.y = 0.0;
  point.z = -1.0;
  NOD (point);
  VXRD (point);
  angle = ANGLE_PI / (double) stacks;
  sr1 = sin (angle);
  z1 = - cos (angle);
  point.x = sr1;
  point.y = 0.0;
  point.z = z1;
  NOD (point);
  VXRD (point);
  for (slice = slices - 1; slice >= 1; slice--) {
    angle = (double) slice * 2.0 * ANGLE_PI / (double) slices;
    point.x = sr1 * cos (angle);
    point.y = sr1 * sin (angle);
    NOD (point);
    VXRD (point);
  }
  point.x = sr1;
  point.y = 0.0;
  point.z = z1;
  NOD (point);
  VXRD (point);
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_tetrahedron_vertices (vector3 *pos, double radius)
{
  vector3 *point;
  register int slot;
  register double x, y, z;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (tetrahedron == NULL) tetrahedron = tetrahedron_vertices();
  point = tetrahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_POINTS);
  for (slot = 0; slot < 4; slot++) {
    VXR (point);
    point++;
  }
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_tetrahedron_edges (vector3 *pos, double radius)
{
  register double x, y, z;
  vector3 *point;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (tetrahedron == NULL) tetrahedron = tetrahedron_vertices();
  point = tetrahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_LINE_LOOP);
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point++;
  VXR (point);		/* 2 */
  point++;
  VXR (point);		/* 3 */
  glEnd();
  glBegin (GL_LINES);
  VXR (point);		/* 3 */
  point -= 2;
  VXR (point);		/* 1 */
  point--;
  VXR (point);		/* 0 */
  point += 2;
  VXR (point);		/* 2 */
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_tetrahedron_faces (vector3 *pos, double radius)
     /*
       Requires mode glShadeModel(GL_FLAT) for correct rendering.
     */
{
  register double x, y, z;
  vector3 *point;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (tetrahedron == NULL) tetrahedron = tetrahedron_vertices();
  point = tetrahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_TRIANGLE_STRIP);
  average_3_normals (tetrahedron, tetrahedron + 1, tetrahedron + 2);
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point++;
  VXR (point);		/* 2 */
  average_3_normals (tetrahedron + 1, tetrahedron + 2, tetrahedron + 3);
  point++;
  VXR (point);		/* 3 */
  average_3_normals (tetrahedron + 2, tetrahedron + 3, tetrahedron);
  point = tetrahedron;
  VXR (point);		/* 0 */
  average_3_normals (tetrahedron + 3, tetrahedron, tetrahedron + 1);
  point++;
  VXR (point);		/* 1 */
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_octahedron_vertices (vector3 *pos, double radius)
{
  vector3 *point;
  register int slot;
  register double x, y, z;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (octahedron == NULL) octahedron = octahedron_vertices();
  point = octahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_POINTS);
  for (slot = 0; slot < 6; slot++) {
    VXR (point);
    point++;
  }
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_octahedron_edges (vector3 *pos, double radius)
{
  register double x, y, z;
  vector3 *point;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (octahedron == NULL) octahedron = octahedron_vertices();
  point = octahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_LINE_LOOP);
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point++;
  VXR (point);		/* 2 */
  point -= 2;
  VXR (point);		/* 0 */
  point += 3;
  VXR (point);		/* 3 */
  point--;
  VXR (point);		/* 2 */
  point += 3;
  VXR (point);		/* 5 */
  point -= 2;
  VXR (point);		/* 3 */
  point++;
  VXR (point);		/* 4 */
  point -= 3;
  VXR (point);		/* 1 */
  point += 4;
  VXR (point);		/* 5 */
  point--;
  VXR (point);		/* 4 */
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_octahedron_faces (vector3 *pos, double radius)
     /*
       Requires mode glShadeModel(GL_FLAT) for correct rendering.
     */
{
  register double x, y, z;
  vector3 *point;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (octahedron == NULL) octahedron = octahedron_vertices();
  point = octahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_TRIANGLE_FAN);
  average_3_normals (octahedron, octahedron + 1, octahedron + 2);
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point++;
  VXR (point);		/* 2 */
  average_3_normals (octahedron, octahedron + 2, octahedron + 3);
  point++;
  VXR (point);		/* 3 */
  average_3_normals (octahedron, octahedron + 3, octahedron + 4);
  point++;
  VXR (point);		/* 4 */
  average_3_normals (octahedron, octahedron + 4, octahedron + 1);
  point -= 3;
  VXR (point);		/* 1 */
  glEnd();
  glBegin (GL_TRIANGLE_FAN);
  average_3_normals (octahedron + 5, octahedron + 4, octahedron + 3);
  point += 4;
  VXR (point);		/* 5 */
  point--;
  VXR (point);		/* 4 */
  point--;
  VXR (point);		/* 3 */
  average_3_normals (octahedron + 5, octahedron + 3, octahedron + 2);
  point--;
  VXR (point);		/* 2 */
  average_3_normals (octahedron + 5, octahedron + 2, octahedron + 1);
  point--;
  VXR (point);		/* 1 */
  average_3_normals (octahedron + 5, octahedron + 1, octahedron + 4);
  point += 3;
  VXR (point);		/* 4 */
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_cube_vertices (vector3 *pos, double radius)
{
  vector3 *point;
  register int slot;
  register double x, y, z;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (cube == NULL) cube = cube_vertices();
  point = cube;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_POINTS);
  for (slot = 0; slot < 8; slot++) {
    VXR (point);
    point++;
  }
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_cube_edges (vector3 *pos, double radius)
{
  register double x, y, z;
  vector3 *point;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (cube == NULL) cube = cube_vertices();
  point = cube;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_LINE_LOOP);
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point += 2;
  VXR (point);		/* 3 */
  point--;
  VXR (point);		/* 2 */
  glEnd();
  glBegin (GL_LINE_LOOP);
  point += 2;
  VXR (point);		/* 4 */
  point++;
  VXR (point);		/* 5 */
  point += 2;
  VXR (point);		/* 7 */
  point--;
  VXR (point);		/* 6 */
  glEnd();
  glBegin (GL_LINES);
  VXR (point);		/* 6 */
  point -= 6;
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point += 6;
  VXR (point);		/* 7 */
  point -= 4;
  VXR (point);		/* 3 */
  point += 2;
  VXR (point);		/* 5 */
  point--;
  VXR (point);		/* 4 */
  point -= 2;
  VXR (point);		/* 2 */
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_cube_faces (vector3 *pos, double radius)
     /*
       Requires mode glShadeModel(GL_FLAT) for correct rendering.
     */
{
  register double x, y, z;
  vector3 *point;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (cube == NULL) cube = cube_vertices();
  point = cube;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_QUAD_STRIP);
  glNormal3d (0.0, 1.0, 0.0);
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point++;
  VXR (point);		/* 2 */
  point++;
  VXR (point);		/* 3 */
  glNormal3d (-1.0, 0.0, 0.0);
  point++;
  VXR (point);		/* 4 */
  point++;
  VXR (point);		/* 5 */
  glNormal3d (0.0, -1.0, 0.0);
  point++;
  VXR (point);		/* 6 */
  point++;
  VXR (point);		/* 7 */
  glNormal3d (1.0, 0.0, 0.0);
  point -= 7;
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  glEnd();
  glBegin (GL_QUADS);
  glNormal3d (0.0, 0.0, 1.0);
  point--;
  VXR (point);		/* 0 */
  point += 2;
  VXR (point);		/* 2 */
  point += 2;
  VXR (point);		/* 4 */
  point += 2;
  VXR (point);		/* 6 */
  glNormal3d (0.0, 0.0, -1.0);
  point++;
  VXR (point);		/* 7 */
  point -= 2;
  VXR (point);		/* 5 */
  point -= 2;
  VXR (point);		/* 3 */
  point -= 2;
  VXR (point);		/* 1 */
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_icosahedron_vertices (vector3 *pos, double radius)
{
  vector3 *point;
  register int slot;
  register double x, y, z;
  char label[3];

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (icosahedron == NULL) icosahedron = icosahedron_vertices();
  point = icosahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_POINTS);
  for (slot = 0; slot < 12; slot++) {
    VXR (point);
    point++;
  }
  glEnd();

  glPixelStorei (GL_UNPACK_ALIGNMENT, 1);
  for (slot = 0; slot < 12; slot++) {
    sprintf (label, "%2i", slot);
    glRasterPos3d (icosahedron[slot].x,
		   icosahedron[slot].y,
		   icosahedron[slot].z);
    ogl_bitmap_string (GLUT_BITMAP_HELVETICA_18, label);
  }
}


/*------------------------------------------------------------*/
void
ogl_icosahedron_edges (vector3 *pos, double radius)
{
  register double x, y, z;
  vector3 *point;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (icosahedron == NULL) icosahedron = icosahedron_vertices();
  point = icosahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_LINE_STRIP);
  point += 6;
  VXR (point);		/* 6 */
  point -= 2;
  VXR (point);		/* 4 */
  point -= 4;
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point++;
  VXR (point);		/* 2 */
  point++;
  VXR (point);		/* 3 */
  point += 5;
  VXR (point);		/* 8 */
  point -= 4;
  VXR (point);		/* 4 */
  point -= 3;
  VXR (point);		/* 1 */
  point += 4;
  VXR (point);		/* 5 */
  point += 2;
  VXR (point);		/* 7 */
  point += 3;
  VXR (point);		/* 10 */
  point++;
  VXR (point);		/* 11 */
  point -= 5;
  VXR (point);		/* 6 */
  point--;
  VXR (point);		/* 5 */
  point += 4;
  VXR (point);		/* 9 */
  point -= 3;
  VXR (point);		/* 6 */
  point -= 5;
  VXR (point);		/* 1 */
  glEnd();
  glBegin (GL_LINE_STRIP);
  point--;
  VXR (point);		/* 0 */
  point += 8;
  VXR (point);		/* 8 */
  point += 3;
  VXR (point);		/* 11 */
  point -= 7;
  VXR (point);		/* 4 */
  glEnd();
  glBegin (GL_LINE_STRIP);
  point++;
  VXR (point);		/* 5 */
  point -= 3;
  VXR (point);		/* 2 */
  point += 5;
  VXR (point);		/* 7 */
  point += 2;
  VXR (point);		/* 9 */
  point += 2;
  VXR (point);		/* 11 */
  glEnd();
  glBegin (GL_LINE_STRIP);
  point -= 3;
  VXR (point);		/* 8 */
  point += 2;
  VXR (point);		/* 10 */
  point -= 7;
  VXR (point);		/* 3 */
  point += 4;
  VXR (point);		/* 7 */
  glEnd();
  glBegin (GL_LINES);
  point -= 4;
  VXR (point);		/* 3 */
  point -= 3;
  VXR (point);		/* 0 */
  VXR (point);		/* 0 */
  point += 2;
  VXR (point);		/* 2 */
  point += 7;
  VXR (point);		/* 9 */
  point++;
  VXR (point);		/* 10 */
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_icosahedron_faces (vector3 *pos, double radius)
     /*
       Requires mode glShadeModel(GL_FLAT) for correct rendering.
     */
{
  register double x, y, z;
  vector3 *point;

  /* pre */
  assert (pos);
  assert (radius > 0.0);

  if (icosahedron == NULL) icosahedron = icosahedron_vertices();
  point = icosahedron;
  x = pos->x;
  y = pos->y;
  z = pos->z;

  glBegin (GL_TRIANGLE_FAN);
  average_3_normals (icosahedron, icosahedron + 1, icosahedron + 4);
  VXR (point);		/* 0 */
  point++;
  VXR (point);		/* 1 */
  point += 3;
  VXR (point);		/* 4 */
  average_3_normals (icosahedron, icosahedron + 4, icosahedron + 8);
  point += 4;
  VXR (point);		/* 8 */
  average_3_normals (icosahedron, icosahedron + 8, icosahedron + 3);
  point -= 5;
  VXR (point);		/* 3 */
  average_3_normals (icosahedron, icosahedron + 3, icosahedron + 2);
  point--;
  VXR (point);		/* 2 */
  average_3_normals (icosahedron, icosahedron + 2, icosahedron + 1);
  point--;
  VXR (point);		/* 1 */
  glEnd();
  glBegin (GL_TRIANGLE_FAN);
  average_3_normals (icosahedron + 9, icosahedron + 5, icosahedron + 7);
  point += 8;
  VXR (point);		/* 9 */
  point -= 4;
  VXR (point);		/* 5 */
  point += 2;
  VXR (point);		/* 7 */
  average_3_normals (icosahedron + 9, icosahedron + 7, icosahedron + 10);
  point += 3;
  VXR (point);		/* 10 */
  average_3_normals (icosahedron + 9, icosahedron + 10, icosahedron + 11);
  point++;
  VXR (point);		/* 11 */
  average_3_normals (icosahedron + 9, icosahedron + 11, icosahedron + 6);
  point -= 5;
  VXR (point);		/* 6 */
  average_3_normals (icosahedron + 9, icosahedron + 6, icosahedron + 5);
  point--;
  VXR (point);		/* 5 */
  glEnd();
  glBegin (GL_TRIANGLE_STRIP);
  average_3_normals (icosahedron + 2, icosahedron + 5, icosahedron + 1);
  point -= 3;
  VXR (point);		/* 2 */
  point += 3;
  VXR (point);		/* 5 */
  point -= 4;
  VXR (point);		/* 1 */
  average_3_normals (icosahedron + 5, icosahedron + 1, icosahedron + 6);
  point += 5;
  VXR (point);		/* 6 */
  average_3_normals (icosahedron + 1, icosahedron + 6, icosahedron + 4);
  point -= 2;
  VXR (point);		/* 4 */
  average_3_normals (icosahedron + 6, icosahedron + 4, icosahedron + 11);
  point += 7;
  VXR (point);		/* 11 */
  average_3_normals (icosahedron + 4, icosahedron + 11, icosahedron + 8);
  point -= 3;
  VXR (point);		/* 8 */
  average_3_normals (icosahedron + 11, icosahedron + 8, icosahedron + 10);
  point += 2;
  VXR (point);		/* 10 */
  average_3_normals (icosahedron + 8, icosahedron + 10, icosahedron + 3);
  point -= 7;
  VXR (point);		/* 3 */
  average_3_normals (icosahedron + 10, icosahedron + 3, icosahedron + 7);
  point += 4;
  VXR (point);		/* 7 */
  average_3_normals (icosahedron + 3, icosahedron + 7, icosahedron + 2);
  point -= 5;
  VXR (point);		/* 2 */
  average_3_normals (icosahedron + 7, icosahedron + 2, icosahedron + 5);
  point += 3;
  VXR (point);		/* 5 */
  glEnd();
}


/*------------------------------------------------------------*/
static void
disk (vector3 *pos, vector3 *axis, vector3 *arad, vector3 *brad,
      double radius, int segments)
{
  int slot;
  double angle;
  vector3 point;

  assert (pos);
  assert (axis);
  assert (arad);
  assert (brad);
  assert (radius > 0.0);
  assert (segments >= 3);

  glBegin (GL_TRIANGLE_FAN);
  NO (axis);
  VX (pos);
  v3_sum_scaled (&point, pos, radius, arad);
  VXD (point);
  for (slot = segments - 1; slot >= 1; slot--) {
    angle = 2.0 * ANGLE_PI * (double) slot / (double) segments;
    v3_scaled (&point, cos (angle), arad);
    v3_add_scaled (&point, sin (angle), brad);
    v3_sum_scaled (&point, pos, radius, &point);
    VXD (point);
  }
  v3_sum_scaled (&point, pos, radius, arad);
  VXD (point);
  glEnd();
}


/*------------------------------------------------------------*/
void
ogl_cylinder_faces (vector3 *pos1, vector3 *pos2,
		    double radius, int segments, boolean capped)
     /*
       Requires mode glShadeModel(GL_SMOOTH) for correct rendering.
     */
{
  int slot;
  double angle;
  vector3 point, axis, arad, brad, rad;

  assert (pos1);
  assert (pos2);
  assert (pos1 != pos2);
  assert (v3_distance (pos1, pos2) > 0.0);
  assert (radius > 0.0);
  assert (segments >= 3);

  v3_difference (&axis, pos2, pos1);
  v3_cross_product (&brad, &axis, &xaxis);
  if (v3_length (&brad) < 1.0e-10) v3_cross_product (&brad, &axis, &yaxis);
  v3_cross_product (&arad, &brad, &axis);
  v3_normalize (&arad);
  v3_cross_product (&brad, &arad, &axis);
  v3_normalize (&brad);

  glBegin (GL_QUAD_STRIP);
  NOD (arad);
  v3_sum_scaled (&point, pos1, radius, &arad);
  VXD (point);
  v3_sum_scaled (&point, pos2, radius, &arad);
  VXD (point);
  for (slot = 1; slot < segments; slot++) {
    angle = 2.0 * ANGLE_PI * (double) slot / (double) segments;
    v3_scaled (&rad, cos (angle), &arad);
    v3_add_scaled (&rad, sin (angle), &brad);
    NOD (rad);
    v3_sum_scaled (&point, pos1, radius, &rad);
    VXD (point);
    v3_sum_scaled (&point, pos2, radius, &rad);
    VXD (point);
  }
  NOD (arad);
  v3_sum_scaled (&point, pos1, radius, &arad);
  VXD (point);
  v3_sum_scaled (&point, pos2, radius, &arad);
  VXD (point);
  glEnd();

  if (capped) {
    v3_normalize (&axis);
    disk (pos2, &axis, &arad, &brad, radius, segments);
    v3_reverse (&axis);
    v3_reverse (&brad);
    disk (pos1, &axis, &arad, &brad, radius, segments);
  }
}
